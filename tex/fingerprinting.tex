\subsection{Data Fingerprinting}
\label{sec:fingerprinting}
Data fingerprinting is the second deduplication technique we use in our bandwidth reduction mechanism. In general, a fingerprinting function is similar to a hash function in that it is also a one-way function which maps an arbitrarily large input to a fix-sized number, and each unique input has a unique fingerprint value. However, unlike an conventional hash function, this fingerprinting function can be decomposed for the incremental computation of a fingerprint. This is done by representing the input as a polynomial modulo a pre-determined irreducible polynomial \cite{rabin,lbfs}.

Our use of fingerprinting is two-fold: (1) To generate the sliding window chunks, and (2) to generate fingerprints as identifiers for unique chunks. We exploit the fact that any size chunk maps to a fix-sized fingerprint, which is much more efficient to transfer across the network than the entire data chunk. As we discuss in more detail in Section \ref{sec:protocol}, our mechanism requires the transmission of two rounds of fingerprints for data redundancy detection but the total bandwidth savings of our system outweigh these added overhead and bandwidth requirements of these two additional transmissions (see Section \ref{sec:eval}).