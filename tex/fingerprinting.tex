\subsection{Data Fingerprinting}
\label{sec:fingerprinting}
Data fingerprinting is the second deduplication technique we use in our bandwidth reduction mechanism. In general, a fingerprinting function is similar to a hash function in that it is also a one-way function which maps an arbitrarily large input to a fixed-size number, and each unique input has a unique fingerprint value. A Rabin fingerprint does this by representing the input data as a polynomial modulo a pre-determined irreducible polynomial \cite{rabin,lbfs}.

Our use of fingerprinting is two-fold: (1) To generate the sliding window chunks, and (2) to generate fingerprints as identifiers for unique chunks. We exploit the fact that any size chunk maps to a fixed-size fingerprint, which is much more efficient to transfer across the network than the entire data chunk. As we discuss in more detail in Section \ref{sec:protocol}, our mechanism requires the transmission of two rounds of fingerprints for data redundancy detection but the total bandwidth savings of our system outweigh these added overhead and bandwidth requirements of these two additional transmissions (see Section \ref{sec:eval}).