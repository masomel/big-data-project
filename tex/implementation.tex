\section{Simulator Implementation}
\label{sec:implementation}
We implemented two versions of a simulator of our system: 
\begin{enumerate}
\item An offline simulator, which uses data collected and stored during a mobile browsing session, and input into the simulator offline, and
\item A networked simulator, which simulates a basic incarnation of our system in real-time.
\end{enumerate}
Both simulators are written in Java, and use five helper interfaces and classes each one representing a component of the system, in addition to the proxy server and mobile device classes. In particular, we use two helper interfaces: \texttt{ICache} and \texttt{IProcessor}, which allow for different implementations of caches supporting various eviction algorithms, and of what we call cache processors, respectively. A cache processor is an entity which acts as an interface between a device and its web cache, with its most important task to process incoming web content based on the device's cache contents. While both of our simulators use a simple implementation of \texttt{IProcessor} called \texttt{SimpleProcessor}, which manages web content caching, and measures the cache hitrate and missrate, we have multiple implementations of \texttt{ICache}, which we address later in this section. 

The three helper functions we use are \texttt{Chunk}, \texttt{Chunking} and \texttt{Fingerprinting}. The \texttt{Chunk} class defines a fixed-size data chunk with a given size in number of bytes and the data. \texttt{Chunking} is the facility which generates all the data chunks for a given input, either an input file containing web page data or a data stream of online web data. The \texttt{Fingerprinting} class is a wrapper for the Java \emph{rabinhash} library written by Sean Owen \cite{rabinhash}, and uses the \texttt{RabinHashFunction32} implementation of Rabin's fingerprinting method creating 32-bit fingerprints of a given data chunk \cite{rabin_api}.

Finally, we created the \texttt{ISimulator} interface to build different kinds of simulators. Our offline version uses one or more \texttt{Mobile} devices and a \texttt{ProxyServer} to implement the simulation of our reduction protocol described in Section \ref{sec:protocol}. The networked simulator uses the networked counterparts of these two components.

Figure \ref{fig:class_diagram} summarizes our entire implementation software architecture.

\begin{figure*}[ht] 
%\centering \includegraphics[scale=0.40]{images/class_diagram.png}
\caption{Implementation Software Class Hierarchy.}
\label{fig:class_diagram}
\end{figure*}

\input{offline_sim}
\input{networked_sim}
\input{impl_caching}
